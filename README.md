# 杂谈
## Introduction to data structure
### 线性结构
线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表。

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196073863-67dd00c2-67b7-4b81-be08-b85c10ef0bae.png" width="600">
</div>

### 树
树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196073872-e4931893-ec3c-4e95-9768-82c006165ee1.png" width="300">
</div>

### 图
图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196073895-96964919-f6cf-455b-bb97-639f70d19967.png" width="300">
</div>

### 其他数据结构
除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据结构。它们由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等。

## 关于算法的好坏
### 渐进时间复杂度（asymptotic time complexity）
设T(n)为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间函数），n为输入规模，程序中最常见的4种执行方式分别是：
* T(n) = 3n，执行次数是线性的
* T(n) = 5logn，执行次数是用对数计算的
* T(n) = 2，执行次数是常量
* T(n) = 0.5n^2 + 0.5n，执行次数是用多项式计算的

若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的**极限值**为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。

因为渐进时间复杂度用大写O来表示，所以也被称为大O表示法。如：
* T(n) = O(n)
* T(n) = O(logn)
* T(n) = O(1)
* T(n) = =O(n^2)
不难得出以下结论：

$$
\mathrm{O}(1)<\mathrm{O}(\log n)<\mathrm{O}(\mathrm{n})<\mathrm{O}\left(\mathrm{n}^2\right)
$$

还有很多其他的时间复杂度： $\mathrm{O}(\mathrm{nlogn}) 、 \mathrm{O}\left(\mathrm{n}^3\right) 、 \mathrm{O}(\mathrm{mn}) 、 \mathrm{O}\left(2^{\mathrm{n}}\right) 、 \mathrm{O}(\mathrm{n} !)$

### 空间复杂度
和时间复杂度类似，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大O表示法。

程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数

#### 常量空间
当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1)。

#### 线性空间
当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。

#### 二维空间
当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n2)。

#### 递归空间
递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。

“方法调用栈”包括进栈和出栈两个行为。当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈中。当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。

由上面“方法调用栈”的出入栈过程可以看出，**执行递归操作所需要的内存空间和递归的深度成正比**。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。

# 数据结构基础
## 数组
数组对应的英文是array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

数组的另一个特点，是在内存中顺序存储，因此可以很好地实现逻辑上的顺序表。

* 数组读取元素和更新元素的时间复杂度都是O(1)
* 数组扩容的时间复杂度是O(n)，插入并移动元素的时间复杂度也是O(n)，综合起来插入操作的时间复杂度是O(n)。
* 删除操作，只涉及元素的移动，时间复杂度也是O(n)。

### 数组的优劣势
优势：数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫作二分查找，就是利用了数组的这个优势。

劣势：数组的劣势，体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

总的来说，数组所适合的是读操作多、写操作少的场景，而链表则恰恰相反

## 链表
链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。

单向链表的每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。

双向链表比单向链表稍微复杂一些，它的每一个节点除了拥有data和next指针，还拥有指向前置节点的prev指针。

这正如地下党的联络方式，一级一级，单线传递。
### 内存储存方式
如果说数组在内存中的存储方式是顺序存储，那么链表在内存中的存储方式则是随机存储。

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196078719-87590c47-d65b-4fb3-99c2-6490fb700c31.png" width="600">
</div>

### 基本操作
**查找节点**：在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。链表中的数据只能按顺序进行访问，最坏的时间复杂度是O(n)。
**更新节点**：如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可

## 数组 VS 链表

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196079089-7e25e149-698b-4a7f-938f-6dbc4c025d7a.png" width="600">
</div>

从表格可以看出，数组的优势在于能够快速定位元素，对于读操作多、写操作少的场景来说，用数组更合适一些。

相反地，链表的优势在于能够灵活地进行插入和删除操作，如果需要在尾部频繁插入、删除元素，用链表更合适一些。

## 栈和队列
逻辑结构是抽象的概念，它依赖于物理结构而存在。

<div align=center>
<img src="https://user-images.githubusercontent.com/111955215/196079429-9715da93-7ebc-4f8b-85a7-beaf93279bec.png" width="500">
</div>

两个常用数据结构：栈和队列。这两者都属于逻辑结构，它们的物理实现既可以利用数组，也可以利用链表来完成。

### 栈 stack
栈（stack）是一种线性数据结构，栈中的元素只能先入后出（First In Last Out，简称FILO）。最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。栈这种数据结构既可以用数组来实现，也可以用链表来实现。
#### 栈的基本操作
入栈 push：把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。以数组为例：
![image](https://user-images.githubusercontent.com/111955215/196079971-818060ec-a5e6-4fae-859b-25df593d7c1c.png)

出栈 pop：把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。
![image](https://user-images.githubusercontent.com/111955215/196079983-0b401802-39b2-4bb6-9469-1c12730746d1.png)

入栈和出栈只会影响到最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是以链表实现，入栈、出栈的时间复杂度都是O(1)。

### 队列
队列（queue）是一种线性数据结构，它的特征和行驶车辆的单行隧道很相似。不同于栈的先入后出，队列中的元素只能先入先出（First In First Out，简称FIFO）。队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）

与栈类似，队列这种数据结构既可以用数组来实现，也可以用链表来实现。
#### 队列的基本操作
入队（enqueue）：把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。
出队操作（dequeue）：把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

如果像这样不断出队，队头左边的空间失去作用，那队列的容量岂不是越来越小了？

用数组实现的队列可以采用**循环队列**的方式来维持队列容量的恒定
![image](https://user-images.githubusercontent.com/111955215/196080588-67375ce5-c024-458a-8638-80c2db0d4cad.png)
